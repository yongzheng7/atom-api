package com.atom.compiler.codegen;

import com.atom.annotation.AutoClass;
import com.atom.annotation.bean.ApiImpls;
import com.atom.compiler.processor.ApiImplsProcessor;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.lang.model.element.Modifier;

@SuppressWarnings({"WeakerAccess"})
public class MetaApis {

    private final Context mContext;
    private final String metaModelPackage;
    private final String metaModelName;

    public MetaApis(Context context, String bundleClassname) {
        this.mContext = context;
        this.metaModelPackage = context.packet();
        this.metaModelName = bundleClassname;
    }

    public void writeFile(Set<MetaApi> apies) {

        // need to generate the body first, since this will also update the required imports which need to
        // be written out first
        ClassName pageConfigClassName = ClassName.get(metaModelPackage, metaModelName);
        mContext.logger().warning("warning >>> " + pageConfigClassName.canonicalName());

        TypeSpec.Builder pageConfigBuilder = TypeSpec.classBuilder(pageConfigClassName)
                .superclass(ClassName.get(ApiImpls.class));

        String format = mContext.dateformat().format(new Date());
        // 代码创建 文档
        CodeBlock javaDoc = CodeBlock.builder()
                .add("<p>This is a class automatically generated by API annotation processor, which is used to register the page automatically.</p>")
                .add("\n")
                .add("@date ").add(format)
                .add("\n")
                .build();

        AnnotationSpec GeneratedAnnountation = AnnotationSpec.builder(AutoClass.class)
                .addMember("value", "$S", ApiImplsProcessor.class.getName())
                .addMember("date", "$S", format)
                .build();

        AnnotationSpec suppressWarningsAnnountation = AnnotationSpec.builder(SuppressWarnings.class)
                .addMember("value", "$S", "all")
                .build();

        MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC);

        Iterator<MetaApi> iterator = apies.iterator();
        while (iterator.hasNext()) {
            MetaApi next = iterator.next();
            String apiQualifiedName = next.getApiQualifiedName();
            if (apiQualifiedName != null) {
                boolean isHasApi = mContext.hasApi(apiQualifiedName);
                if (isHasApi) {
                    continue;
                } else {
                    mContext.putApi(apiQualifiedName);
                }
                List<SingleImpl> singleList = new ArrayList<>();
                List<ClassName> implNames = getImplNames(next, apies, singleList);
                if (!implNames.isEmpty()) {
                    int size = implNames.size();
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("add(");
                    for (; size != 0; size--) {
                        stringBuilder.append("$L.class");
                        if (size != 1) {
                            stringBuilder.append(",");
                        }
                    }
                    stringBuilder.append(")");
                    String s = stringBuilder.toString();
                    mContext.logger().warning("warning >>> " + s);
                    ClassName[] classNames = implNames.toArray(new ClassName[]{});
                    constructorBuilder.addStatement(s, (Object[]) classNames);
                    for (SingleImpl impl : singleList
                    ) {
                        if(impl.name.isEmpty()) continue;
                        constructorBuilder.addStatement("add($S , $L.class , $L.class , "+impl.version+")" , impl.name , impl.apiClass , impl.implClass);
                    }
                }
            }
        }
        MethodSpec constructor = constructorBuilder.build();

        pageConfigBuilder
                .addJavadoc(javaDoc)
                .addAnnotation(GeneratedAnnountation)
                .addAnnotation(suppressWarningsAnnountation)
                .addModifiers(Modifier.PUBLIC)
                .addMethod(constructor);
        JavaFile.Builder builder = JavaFile.builder(metaModelPackage, pageConfigBuilder.build());
        JavaFile build = builder.build();
        try {
            build.writeTo(mContext.getFiler());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private List<ClassName> getImplNames(MetaApi api, Collection<MetaApi> impls, List<SingleImpl> result) {
        final List<ClassName> list = new ArrayList<>();
        ClassName apiClassName = ClassName.get(api.getApiTypeElement());
        for (MetaApi metaApi : impls) {
            if (!metaApi.isApiImpl(api.getApiQualifiedName())) {
                continue;
            }
            ClassName implClassName = ClassName.get(metaApi.getImplTypeElement());
            list.add(implClassName);
            result.add(new SingleImpl(apiClassName, implClassName, metaApi.getImplAnnotationName(), metaApi.getImplAnnotationVersion()));
        }
        if (!list.isEmpty()) {
            list.add(0, apiClassName);
        }
        return list;
    }

    static class SingleImpl {
        ClassName apiClass;
        ClassName implClass;
        String name;
        long version;

        public SingleImpl(ClassName apiClass, ClassName implClass, String name, long version) {
            this.apiClass = apiClass;
            this.implClass = implClass;
            this.name = name;
            this.version = version;
        }
    }
}
