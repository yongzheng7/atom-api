package com.atom.apt.codegen;

import com.atom.apt.annotation.ApiImpls;
import com.atom.apt.annotation.AutoClass;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.annotation.Generated;
import javax.lang.model.element.Modifier;

@SuppressWarnings({"WeakerAccess"})
public class MetaApis {

    private final Context mContext;
    private final String mQualifiedName;

    public MetaApis(Context context, String bundleClassname) {
        this.mContext = context;
        this.mQualifiedName = bundleClassname;
    }

    public void writeFile(Set<MetaApi> apies) {
        String metaModelPackage = qualifier(mQualifiedName);
        String metaModelName = unqualify(mQualifiedName);
        // need to generate the body first, since this will also update the required imports which need to
        // be written out first
        ClassName pageConfigClassName = ClassName.get(metaModelPackage, metaModelName);
        mContext.logger().warning("warning >>> " + pageConfigClassName.canonicalName());

        TypeSpec.Builder pageConfigBuilder = TypeSpec.classBuilder(pageConfigClassName)
                .superclass(ClassName.get(ApiImpls.class));

        String format = Context.SIMPLE_DATE_FORMAT.get().format(new Date());
        // 代码创建 文档
        CodeBlock javaDoc = CodeBlock.builder()
                .add("<p>This is a class automatically generated by API annotation processor, which is used to register the page automatically.</p>")
                .add("\n")
                .add("@date ").add(format)
                .add("\n")
                .build();

        AnnotationSpec GeneratedAnnountation = AnnotationSpec.builder(AutoClass.class)
                .addMember("value", "$S", ApiAnnotationProcessor.class.getName())
                .addMember("date", "$S", format)
                .build();

        AnnotationSpec suppressWarningsAnnountation = AnnotationSpec.builder(SuppressWarnings.class)
                .addMember("value", "$S" , "all")
                .build();

        MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC);

        Iterator<MetaApi> iterator = apies.iterator();
        while (iterator.hasNext()) {
            MetaApi next = iterator.next();
            String apiQualifiedName = next.getApiQualifiedName();
            if (apiQualifiedName != null) {
                boolean isHasApi = mContext.isApi(apiQualifiedName);
                if(isHasApi){
                    continue;
                }else{
                    mContext.putApi(apiQualifiedName);
                }
                List<ClassName> implNames = getImplNames(next, apies);
                if (implNames.isEmpty()) {
                    continue;
                } else {
                    int size = implNames.size();
                    StringBuilder stringBuilder = new StringBuilder();
                    mContext.logger().warning("warning >>> size >>>" +size);
                    stringBuilder.append("add(") ;
                    for (; size != 0; size--) {
                        stringBuilder.append("$L.class") ;
                        if(size!= 1){
                            stringBuilder.append(",");
                        }
                    }
                    stringBuilder.append(")") ;
                    String s = stringBuilder.toString();
                    mContext.logger().warning("warning >>> " +s);
                    ClassName[] classNames = implNames.toArray(new ClassName[]{});
                    constructorBuilder.addStatement(s , (Object[]) classNames);
                }

            }
        }
        MethodSpec constructor = constructorBuilder.build();

        pageConfigBuilder
                .addJavadoc(javaDoc)
                .addAnnotation(GeneratedAnnountation)
                .addAnnotation(suppressWarningsAnnountation)
                .addModifiers(Modifier.PUBLIC)
                .addMethod(constructor);
        JavaFile.Builder builder = JavaFile.builder(metaModelPackage, pageConfigBuilder.build());
        JavaFile build = builder.build();
        try {
            build.writeTo(mContext.getFiler());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private List<ClassName> getImplNames(MetaApi api, Collection<MetaApi> impls) {
        final List<ClassName> list = new ArrayList<>();
        for (MetaApi metaApi : impls) {
            if (!metaApi.isApiImpl(api.getApiQualifiedName())) {
                continue;
            }
            list.add(ClassName.get(metaApi.getImplTypeElement()));
        }
        if (!list.isEmpty()) {
            list.add(0, ClassName.get(api.getApiTypeElement()));
        }
        return list;
    }


    public static String unqualify(String qualifiedName) {
        int loc = qualifiedName.lastIndexOf('.');
        return (loc < 0) ? qualifiedName : qualifiedName.substring(qualifiedName.lastIndexOf('.') + 1);
    }


    public static String qualifier(String qualifiedName) {
        int loc = qualifiedName.lastIndexOf(".");
        return (loc < 0) ? "" : qualifiedName.substring(0, loc);
    }
}
